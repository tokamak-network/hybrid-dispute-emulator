<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hybrid Dispute Dashboard</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #0f0f0f;
            color: #e0e0e0;
            min-height: 100vh;
        }
        .header {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            padding: 1rem 2rem;
            border-bottom: 1px solid #333;
        }
        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #fff;
        }
        .header .status {
            font-size: 0.85rem;
            color: #888;
            margin-top: 0.25rem;
        }
        .header .status.connected {
            color: #4ade80;
        }
        .main {
            display: grid;
            grid-template-columns: 280px 1fr;
            grid-template-rows: 1fr 200px;
            height: calc(100vh - 80px);
            gap: 1px;
            background: #333;
        }
        .panel {
            background: #1a1a1a;
            padding: 1rem;
            overflow: auto;
        }
        .panel h2 {
            font-size: 0.9rem;
            font-weight: 600;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #333;
        }
        .control-panel {
            grid-row: span 2;
        }
        .cost-params {
            margin-bottom: 1rem;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 0.5rem;
        }
        .cost-params summary {
            cursor: pointer;
            font-size: 0.8rem;
            color: #888;
            padding: 0.25rem;
        }
        .cost-params summary:hover {
            color: #aaa;
        }
        .cost-params[open] summary {
            margin-bottom: 0.5rem;
            border-bottom: 1px solid #333;
            padding-bottom: 0.5rem;
        }
        .cost-params .form-group {
            margin-bottom: 0.5rem;
        }
        .cost-params .form-group label {
            font-size: 0.7rem;
        }
        .cost-params .form-group input {
            padding: 0.3rem;
            font-size: 0.8rem;
        }
        .form-group {
            margin-bottom: 1rem;
        }
        .form-group label {
            display: block;
            font-size: 0.8rem;
            color: #888;
            margin-bottom: 0.25rem;
        }
        .form-group input {
            width: 100%;
            padding: 0.5rem;
            background: #0f0f0f;
            border: 1px solid #333;
            border-radius: 4px;
            color: #fff;
            font-size: 0.9rem;
        }
        .form-group input:focus {
            outline: none;
            border-color: #4a9eff;
        }
        .btn {
            width: 100%;
            padding: 0.6rem 1rem;
            margin-bottom: 0.5rem;
            background: #2563eb;
            border: none;
            border-radius: 4px;
            color: #fff;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
        }
        .btn:hover {
            background: #1d4ed8;
        }
        .btn:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }
        .btn.primary {
            background: #059669;
        }
        .btn.primary:hover {
            background: #047857;
        }
        .tree-view {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .tree-view svg {
            width: 100%;
            height: 100%;
        }
        .tree-placeholder {
            color: #444;
            text-align: center;
        }
        .cost-panel {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.8rem;
        }
        .cost-panel table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 0.5rem;
        }
        .cost-panel th, .cost-panel td {
            padding: 0.4rem 0.5rem;
            text-align: left;
            border-bottom: 1px solid #333;
        }
        .cost-panel th {
            color: #888;
            font-weight: 500;
        }
        .cost-panel .highlight {
            color: #4ade80;
        }
        .event-log {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.75rem;
            background: #0a0a0a;
            padding: 0.5rem;
            border-radius: 4px;
            max-height: 150px;
            overflow-y: auto;
        }
        .event-log .entry {
            padding: 0.2rem 0;
            border-bottom: 1px solid #1a1a1a;
        }
        .event-log .time {
            color: #666;
            margin-right: 0.5rem;
        }
        .event-log .msg {
            color: #aaa;
        }
        .event-log .msg.success {
            color: #4ade80;
        }
        .event-log .msg.error {
            color: #f87171;
        }
        .node circle {
            fill: #2563eb;
            stroke: #4a9eff;
            stroke-width: 2px;
        }
        .node.leaf circle {
            fill: #059669;
            stroke: #4ade80;
        }
        .node text {
            font-size: 10px;
            fill: #ccc;
        }
        .link {
            fill: none;
            stroke: #444;
            stroke-width: 1.5px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Hybrid Dispute Dashboard</h1>
        <div class="status" id="status">Connecting...</div>
    </div>

    <div class="main">
        <div class="panel control-panel">
            <h2>Control Panel</h2>

            <div class="form-group">
                <label>TX Count</label>
                <input type="number" id="txCount" value="5" min="1" max="100">
            </div>

            <details class="cost-params">
                <summary>Cost Parameters</summary>
                <div class="form-group">
                    <label>Compressed Base Fee (PROVE)</label>
                    <input type="number" id="compressedBaseFee" value="0.2" step="0.01" min="0">
                </div>
                <div class="form-group">
                    <label>Compressed PGU Price (PROVE/bPGU)</label>
                    <input type="number" id="compressedPguPrice" value="0.45" step="0.01" min="0">
                </div>
                <div class="form-group">
                    <label>Plonk Fee (PROVE)</label>
                    <input type="number" id="plonkFee" value="0.3" step="0.01" min="0">
                </div>
                <div class="form-group">
                    <label>PROVE Price (USD)</label>
                    <input type="number" id="provePrice" value="0.34" step="0.01" min="0">
                </div>
            </details>

            <button class="btn" id="btnSendTxs" onclick="sendTxs()">Send TXs</button>
            <button class="btn" id="btnBuildTree" onclick="buildTree()">Build Tree</button>
            <button class="btn" id="btnEstimate" onclick="estimateCost()">Estimate Cost</button>

            <hr style="border: none; border-top: 1px solid #333; margin: 1rem 0;">

            <button class="btn primary" id="btnRunAll" onclick="runAll()">Run All</button>

            <div style="margin-top: 1.5rem;">
                <h2>Block Range</h2>
                <div class="form-group">
                    <label>Start Block</label>
                    <input type="number" id="blockStart" value="" placeholder="auto">
                </div>
                <div class="form-group">
                    <label>End Block</label>
                    <input type="number" id="blockEnd" value="" placeholder="auto">
                </div>
            </div>
        </div>

        <div class="panel tree-view" id="treeView">
            <div class="tree-placeholder">
                <p>No commitment tree loaded</p>
                <p style="font-size: 0.8rem; margin-top: 0.5rem;">Send TXs and build tree to visualize</p>
            </div>
        </div>

        <div class="panel cost-panel" id="costPanel">
            <h2>Cost Estimation</h2>
            <div id="costContent">
                <p style="color: #666;">Run estimation to see cost breakdown</p>
            </div>
        </div>

        <div class="panel">
            <h2>Event Log</h2>
            <div class="event-log" id="eventLog"></div>
        </div>
    </div>

    <script>
        // State
        let currentBlockRange = { start: null, end: null };
        let treeData = null;

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            checkStatus();
            log('Dashboard initialized');
        });

        // Logging
        function log(msg, type = '') {
            const logEl = document.getElementById('eventLog');
            const time = new Date().toLocaleTimeString('en-US', { hour12: false });
            const entry = document.createElement('div');
            entry.className = 'entry';
            entry.innerHTML = `<span class="time">[${time}]</span><span class="msg ${type}">${msg}</span>`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
        }

        // Status check
        async function checkStatus() {
            try {
                const res = await fetch('/api/status');
                const data = await res.json();
                const statusEl = document.getElementById('status');

                if (data.connected) {
                    statusEl.textContent = `Connected | L2 Block: ${data.l2_block}`;
                    statusEl.className = 'status connected';
                } else {
                    statusEl.textContent = 'Not connected to devnet';
                    statusEl.className = 'status';
                }

                if (data.tree_loaded && data.tree_block_range) {
                    currentBlockRange.start = data.tree_block_range[0];
                    currentBlockRange.end = data.tree_block_range[1];
                    document.getElementById('blockStart').value = currentBlockRange.start;
                    document.getElementById('blockEnd').value = currentBlockRange.end;
                }
            } catch (e) {
                log('Failed to check status: ' + e.message, 'error');
            }
        }

        // Disable/enable buttons
        function setButtonsDisabled(disabled) {
            document.getElementById('btnSendTxs').disabled = disabled;
            document.getElementById('btnBuildTree').disabled = disabled;
            document.getElementById('btnEstimate').disabled = disabled;
            document.getElementById('btnRunAll').disabled = disabled;
        }

        // Send TXs via SSE
        async function sendTxs() {
            const count = parseInt(document.getElementById('txCount').value) || 5;
            log(`Sending ${count} transactions...`);
            setButtonsDisabled(true);

            try {
                const response = await fetch('/api/send-txs', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ count })
                });

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop();

                    for (const line of lines) {
                        if (line.startsWith('data:')) {
                            try {
                                const data = JSON.parse(line.slice(5).trim());
                                handleTxEvent(data);
                            } catch (e) {}
                        }
                    }
                }
            } catch (e) {
                log('TX send error: ' + e.message, 'error');
            }

            setButtonsDisabled(false);
            checkStatus();
        }

        function handleTxEvent(data) {
            if (data.step === 'started') {
                log(data.message);
            } else if (data.step === 'tx_sent') {
                const shortHash = data.tx_hash ? data.tx_hash.slice(0, 10) + '...' : 'pending';
                log(`TX ${data.index}/${data.total} sent: ${shortHash}`, 'success');
            } else if (data.step === 'waiting') {
                log(data.message);
            } else if (data.block_start !== undefined) {
                // Complete event
                currentBlockRange.start = data.block_start;
                currentBlockRange.end = data.block_end;
                document.getElementById('blockStart').value = data.block_start;
                document.getElementById('blockEnd').value = data.block_end;
                log(`Complete! Block range: ${data.block_start} → ${data.block_end}`, 'success');
            } else if (data.error) {
                log(`Error: ${data.error}`, 'error');
            }
        }

        // Build Tree via SSE
        async function buildTree() {
            const blockStart = parseInt(document.getElementById('blockStart').value);
            const blockEnd = parseInt(document.getElementById('blockEnd').value);

            if (!blockStart || !blockEnd) {
                log('Please set block range first (send TXs or enter manually)', 'error');
                return;
            }

            log(`Building commitment tree for blocks ${blockStart} → ${blockEnd}...`);
            setButtonsDisabled(true);

            try {
                const response = await fetch('/api/build-tree', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ block_start: blockStart, block_end: blockEnd })
                });

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop();

                    for (const line of lines) {
                        if (line.startsWith('data:')) {
                            try {
                                const data = JSON.parse(line.slice(5).trim());
                                handleTreeEvent(data);
                            } catch (e) {}
                        }
                    }
                }
            } catch (e) {
                log('Tree build error: ' + e.message, 'error');
            }

            setButtonsDisabled(false);
            await loadAndRenderTree();
        }

        function handleTreeEvent(data) {
            if (data.step === 'started' || data.step === 'building') {
                log(data.message);
            } else if (data.step === 'collecting') {
                if (data.index % 5 === 0 || data.index === data.total) {
                    log(`Collecting state roots: ${data.index}/${data.total}`);
                }
            } else if (data.depth !== undefined) {
                // Complete event
                log(`Tree complete! Depth: ${data.depth}, Nodes: ${data.total_nodes}, Leaves: ${data.leaves}`, 'success');
                log(`Root: ${data.root?.slice(0, 18)}...`, 'success');
            } else if (data.message) {
                log(data.message, data.message.includes('Error') ? 'error' : '');
            }
        }

        // Load and render tree from server
        async function loadAndRenderTree() {
            try {
                const res = await fetch('/api/tree');
                const data = await res.json();

                if (data.error || !data.tree) {
                    log('No tree data available');
                    return;
                }

                treeData = data;
                renderTree(data.tree);
            } catch (e) {
                log('Failed to load tree: ' + e.message, 'error');
            }
        }

        // D3.js Tree Visualization
        function renderTree(data) {
            const container = document.getElementById('treeView');
            container.innerHTML = '';

            if (!data || !data.hash) {
                container.innerHTML = '<div class="tree-placeholder"><p>No tree data</p></div>';
                return;
            }

            const width = container.clientWidth;
            const height = container.clientHeight;
            const margin = { top: 40, right: 40, bottom: 40, left: 40 };

            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const treeLayout = d3.tree()
                .size([width - margin.left - margin.right, height - margin.top - margin.bottom - 60]);

            const root = d3.hierarchy(data);
            treeLayout(root);

            // Links
            g.selectAll('.link')
                .data(root.links())
                .enter()
                .append('path')
                .attr('class', 'link')
                .attr('d', d3.linkVertical()
                    .x(d => d.x)
                    .y(d => d.y));

            // Nodes
            const nodes = g.selectAll('.node')
                .data(root.descendants())
                .enter()
                .append('g')
                .attr('class', d => 'node' + (d.data.isLeaf ? ' leaf' : ''))
                .attr('transform', d => `translate(${d.x},${d.y})`);

            nodes.append('circle')
                .attr('r', 8)
                .on('click', (event, d) => showNodeDetails(d.data));

            nodes.append('text')
                .attr('dy', -12)
                .attr('text-anchor', 'middle')
                .text(d => d.data.name);

            // Block range labels for leaves
            nodes.filter(d => d.data.isLeaf)
                .append('text')
                .attr('dy', 20)
                .attr('text-anchor', 'middle')
                .attr('font-size', '8px')
                .attr('fill', '#666')
                .text(d => `[${d.data.blockRange[0]}-${d.data.blockRange[1]}]`);

            log('Tree rendered with D3.js');
        }

        function showNodeDetails(node) {
            const details = `
Hash: ${node.hash}
Depth: ${node.depth}
Block Range: ${node.blockRange[0]} → ${node.blockRange[1]}
Is Leaf: ${node.isLeaf}
            `.trim();
            log('Node clicked: ' + node.name);
            alert(details);
        }

        // Estimate Cost via SSE
        async function getSafeBlock() {
            try {
                const res = await fetch('/api/safe-block');
                const data = await res.json();
                return data.safe_block;
            } catch (e) {
                return null;
            }
        }

        async function waitForSafeBlock(blockEnd, timeoutMs = 120000, intervalMs = 5000) {
            const startTime = Date.now();

            while (true) {
                const safeBlock = await getSafeBlock();

                if (safeBlock === null) {
                    log('Failed to fetch safe block status', 'error');
                    return false;
                }

                if (blockEnd <= safeBlock) {
                    log(`Block ${blockEnd} is now safe`, 'success');
                    return true;
                }

                const elapsed = Date.now() - startTime;
                if (elapsed >= timeoutMs) {
                    log(`Timeout: Block ${blockEnd} not yet safe after ${timeoutMs/1000}s (current safe: ${safeBlock})`, 'error');
                    return false;
                }

                log(`Waiting for block ${blockEnd} to reach safe status... (current safe: ${safeBlock})`);
                await new Promise(resolve => setTimeout(resolve, intervalMs));
            }
        }

        async function estimateCost() {
            const blockStart = parseInt(document.getElementById('blockStart').value);
            const blockEnd = parseInt(document.getElementById('blockEnd').value);

            if (!blockStart || !blockEnd) {
                log('Please set block range first', 'error');
                return false;
            }

            // Poll for safe block with timeout
            const isSafe = await waitForSafeBlock(blockEnd);
            if (!isSafe) {
                return false;
            }

            log(`Running cost-estimator for blocks ${blockStart} → ${blockEnd}...`);
            log('This may take several minutes. Please wait...');
            setButtonsDisabled(true);

            try {
                const response = await fetch('/api/estimate-cost', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ block_start: blockStart, block_end: blockEnd })
                });

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop();

                    for (const line of lines) {
                        if (line.startsWith('data:')) {
                            try {
                                const data = JSON.parse(line.slice(5).trim());
                                handleCostEvent(data);
                            } catch (e) {}
                        }
                    }
                }
            } catch (e) {
                log('Cost estimation error: ' + e.message, 'error');
            }

            setButtonsDisabled(false);
            await updateCostPanel();
        }

        function handleCostEvent(data) {
            if (data.step === 'log') {
                log(data.message);
            } else if (data.step === 'started' || data.step === 'info' || data.step === 'parsing') {
                log(data.message);
            } else if (data.totalPgu !== undefined) {
                // Complete event
                log(`Cost estimation complete!`, 'success');
                log(`Total PGU: ${data.totalPgu.toLocaleString()}`, 'success');
                displayCostData(data);
            } else if (data.message) {
                log(data.message, data.message.includes('Error') ? 'error' : '');
            }
        }

        function displayCostData(data) {
            const content = document.getElementById('costContent');
            const params = getCostParams();
            const scenarios = calculateScenarios(data.totalPgu);
            const bpgu = (data.totalPgu / 1_000_000_000).toFixed(2);

            content.innerHTML = `
                <div style="margin-bottom: 0.75rem;">
                    <strong>Batch Info:</strong><br>
                    Blocks: ${data.blockRange[0]} → ${data.blockRange[1]} (${data.numBlocks} blocks)<br>
                    Total PGU: ${data.totalPgu.toLocaleString()} (${bpgu} bPGU)
                </div>
                <div style="margin-bottom: 0.75rem;">
                    <strong>Cycle Breakdown:</strong><br>
                    Blob Verification: ${data.breakdown?.blobVerification?.pct || 0}%<br>
                    Derivation: ${data.breakdown?.derivation?.pct || 0}%<br>
                    Execution: ${data.breakdown?.execution?.pct || 0}%
                </div>
                <table>
                    <tr><th>Scenario</th><th>bPGU</th><th>Comp.</th><th>Plonk</th><th>Total</th><th>USD</th></tr>
                    ${scenarios.map(s => `
                        <tr class="${s.depth > 0 ? 'highlight' : ''}">
                            <td>${s.label}</td>
                            <td>${s.bpgu}</td>
                            <td>${s.compressed}</td>
                            <td>${s.plonk}</td>
                            <td>${s.total}</td>
                            <td>$${s.usd}</td>
                        </tr>
                    `).join('')}
                </table>
            `;
        }

        function calculateProofCost(totalPgu, depth, params) {
            let bpgu = totalPgu / 1_000_000_000;
            if (depth > 0) {
                bpgu = bpgu / Math.pow(2, depth);
            }
            const compressed = params.compressedBaseFee + (bpgu * params.compressedPguPrice);
            const total = compressed + params.plonkFee;
            return { bpgu, compressed, plonk: params.plonkFee, total };
        }

        function calculateScenarios(totalPgu) {
            const params = getCostParams();
            const depths = [0, 5, 7, 10, 11];

            return depths.map(d => {
                const cost = calculateProofCost(totalPgu, d, params);
                return {
                    label: d === 0 ? 'Full Batch' : `Bisect d=${d}`,
                    depth: d,
                    bpgu: cost.bpgu.toFixed(4),
                    compressed: cost.compressed.toFixed(3),
                    plonk: cost.plonk.toFixed(1),
                    total: cost.total.toFixed(3),
                    usd: (cost.total * params.provePrice).toFixed(3)
                };
            });
        }

        async function updateCostPanel() {
            try {
                const provePrice = parseFloat(document.getElementById('provePrice').value) || 0.34;
                const res = await fetch(`/api/cost-model?prove_price_usd=${provePrice}`);
                const data = await res.json();

                if (data.error) {
                    return;
                }

                // Already displayed via handleCostEvent
            } catch (e) {
                // Ignore
            }
        }

        // Run All
        async function runAll() {
            log('=== Starting Full Pipeline ===');

            // Step 1: Send TXs
            await sendTxs();

            // Step 2: Build Tree
            await buildTree();

            // Step 3: Wait for safe block and estimate cost
            log('Running cost estimation (will poll for safe block)...');
            await estimateCost();

            log('=== Pipeline Complete ===', 'success');
        }
    </script>
</body>
</html>
